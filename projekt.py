# -*- coding: utf-8 -*-
"""Projekt.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1A1fTjdhgZHoZSFqlJVns3N8YrCObwfex
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import gamma
from scipy.optimize import curve_fit
from scipy.stats import norm

# Funkcja do obliczania różnicy poziomów zaawansowania
def oblicz_roznice_poziomow(etap, sredni_poziom_zaawansowania):
    return sredni_poziom_zaawansowania - etap['poziom_trudnosci']

# Funkcja do obliczania dostosowanej szansy na niezrobienie
def oblicz_szanse_na_niezrobienie(etap, roznica_poziomow):
    bazowa_szansa = etap['przezywalnosc'] / etap['ilosc_straznikow']
    korekta_szansy = roznica_poziomow / 10  # Przykładowy współczynnik korekty

    return bazowa_szansa + korekta_szansy

# Symulacja Monte Carlo
liczba_symulacji = 5000
wyniki_symulacji = []

for _ in range(liczba_symulacji):
    # Etap 2: Zgromadzenie 6-osobowej grupy (losowanie dynamiczne)
    zespol = []
    for _ in range(6):
        najszybszy_czas_przejscia = np.random.uniform(low=8, high=240)

        if najszybszy_czas_przejscia == 0 or najszybszy_czas_przejscia > 60:
            # Jeśli czas wynosi zero minut lub od godziny wzwyż, ustaw statystyki na 1-2
            gracz = {
                'poziom_zrozumienia': np.random.randint(low=1, high=2),
                'poziom_komunikacji': np.random.randint(low=1, high=2),
                'poziom_zaopatrzenia': np.random.randint(low=1, high=2),
                'poziom_gry': np.random.randint(low=1, high=2),
                'najszybszy_czas_przejscia': najszybszy_czas_przejscia
            }
        elif 20 < najszybszy_czas_przejscia <= 60:
            # Jeśli czas wynosi od 20 minut do 60 minut, ustaw statystyki na 3-5
            gracz = {
                'poziom_zrozumienia': np.random.randint(low=3, high=5),
                'poziom_komunikacji': np.random.randint(low=3, high=5),
                'poziom_zaopatrzenia': np.random.randint(low=3, high=5),
                'poziom_gry': np.random.randint(low=3, high=5),
                'najszybszy_czas_przejscia': najszybszy_czas_przejscia
            }
        elif 8 <= najszybszy_czas_przejscia <= 20:
            # Jeśli czas wynosi od 8 minut do 20 minut, ustaw statystyki na 6
            gracz = {
                'poziom_zrozumienia': 6,
                'poziom_komunikacji': 6,
                'poziom_zaopatrzenia': 6,
                'poziom_gry': 6,
                'najszybszy_czas_przejscia': najszybszy_czas_przejscia
            }

        zespol.append(gracz)

    # Utwórz zespół, który liczy średnią z wartości każdego gracza
    sredni_poziom_zrozumienia = np.mean([gracz['poziom_zrozumienia'] for gracz in zespol])
    sredni_poziom_komunikacji = np.mean([gracz['poziom_komunikacji'] for gracz in zespol])
    sredni_poziom_zaopatrzenia = np.mean([gracz['poziom_zaopatrzenia'] for gracz in zespol])
    sredni_poziom_gry = np.mean([gracz['poziom_gry'] for gracz in zespol])

    sredni_zespol = {
        'poziom_zrozumienia': sredni_poziom_zrozumienia,
        'poziom_komunikacji': sredni_poziom_komunikacji,
        'poziom_zaopatrzenia': sredni_poziom_zaopatrzenia,
        'poziom_gry': sredni_poziom_gry
    }

    # Etapy 3-8: Własne parametry dla każdego etapu
    etap_otwarcie = {
        'poziom_trudnosci': 1,
        'przezywalnosc': 6,
        'ilosc_straznikow': 5,
        'czas_minimalny': np.random.uniform(low=2, high=6),
    }

    etap_totemy = {
        'poziom_trudnosci': 3,
        'przezywalnosc': 3,
        'ilosc_straznikow': 6,
        'czas_minimalny': np.random.uniform(low=5, high=10),
    }

    etap_kaplan_bojowy = {
        'poziom_trudnosci': 5,
        'przezywalnosc': 2,
        'ilosc_straznikow': 6,
        'czas_minimalny': np.random.uniform(low=7, high=15),
    }

    etap_morgeth = {
        'poziom_trudnosci': 6,
        'przezywalnosc': 1,
        'ilosc_straznikow': 6,
        'czas_minimalny': np.random.uniform(low=5, high=10),
    }

    etap_siostry = {
        'poziom_trudnosci': 4,
        'przezywalnosc': 3,
        'ilosc_straznikow': 6,
        'czas_minimalny': np.random.uniform(low=2, high=4),
    }

    etap_oryx = {
        'poziom_trudnosci': 5,
        'przezywalnosc': 3,
        'ilosc_straznikow': 6,
        'czas_minimalny': np.random.uniform(low=5, high=10),
    }

    # Oblicz średni poziom zaawansowania
    sredni_poziom_zaawansowania = np.mean([sredni_zespol['poziom_zrozumienia'],
                                           sredni_zespol['poziom_komunikacji'],
                                           sredni_zespol['poziom_zaopatrzenia'],
                                           sredni_zespol['poziom_gry']])

    # Przykładowe różnice w poziomach zaawansowania graczy
    roznica_poziomow_otwarcie = oblicz_roznice_poziomow(etap_otwarcie, sredni_poziom_zaawansowania)
    roznica_poziomow_totemy = oblicz_roznice_poziomow(etap_totemy, sredni_poziom_zaawansowania)
    roznica_poziomow_kaplan_bojowy = oblicz_roznice_poziomow(etap_kaplan_bojowy, sredni_poziom_zaawansowania)
    roznica_poziomow_morgeth = oblicz_roznice_poziomow(etap_morgeth, sredni_poziom_zaawansowania)
    roznica_poziomow_siostry = oblicz_roznice_poziomow(etap_siostry, sredni_poziom_zaawansowania)
    roznica_poziomow_oryx = oblicz_roznice_poziomow(etap_oryx, sredni_poziom_zaawansowania)

    # Dostosuj szanse na niezrobienie dla każdego etapu
    szansa_na_niezrobienie_otwarcie = oblicz_szanse_na_niezrobienie(etap_otwarcie, roznica_poziomow_otwarcie)
    szansa_na_niezrobienie_totemy = oblicz_szanse_na_niezrobienie(etap_totemy, roznica_poziomow_totemy)
    szansa_na_niezrobienie_kaplan_bojowy = oblicz_szanse_na_niezrobienie(etap_kaplan_bojowy, roznica_poziomow_kaplan_bojowy)
    szansa_na_niezrobienie_morgeth = oblicz_szanse_na_niezrobienie(etap_morgeth, roznica_poziomow_morgeth)
    szansa_na_niezrobienie_siostry = oblicz_szanse_na_niezrobienie(etap_siostry, roznica_poziomow_siostry)
    szansa_na_niezrobienie_oryx = oblicz_szanse_na_niezrobienie(etap_oryx, roznica_poziomow_oryx)

    # Funkcja do obliczania czasu przejścia dla danego etapu
    def oblicz_czas_przejscia(etap):
        return max(etap['czas_minimalny'], np.random.uniform(low=etap['czas_minimalny'], high=20))

    # Oblicz czas przejścia dla każdego etapu
    czas_przejscia_otwarcie = oblicz_czas_przejscia(etap_otwarcie)
    czas_przejscia_totemy = oblicz_czas_przejscia(etap_totemy)
    czas_przejscia_kaplan_bojowy = oblicz_czas_przejscia(etap_kaplan_bojowy)
    czas_przejscia_morgeth = oblicz_czas_przejscia(etap_morgeth)
    czas_przejscia_siostry = oblicz_czas_przejscia(etap_siostry)
    czas_przejscia_oryx = oblicz_czas_przejscia(etap_oryx)

    # Oblicz całkowity czas przejścia drużyny przez wszystkie etapy
    czas_przejscia_druzyny = (czas_przejscia_otwarcie + czas_przejscia_totemy +
                              czas_przejscia_kaplan_bojowy + czas_przejscia_morgeth +
                              czas_przejscia_siostry + czas_przejscia_oryx)

    wyniki_symulacji.append({
        'zespol': sredni_zespol,
        'czas_zespolowy': czas_przejscia_druzyny
    })

# Zapis czasu przejścia do pliku txt
with open('czas_przejscia.txt', 'w') as file:
    for wynik in wyniki_symulacji:
        file.write(f"{wynik['czas_zespolowy']}\n")

# Wczytanie danych z pliku
czas_przejscia = np.loadtxt('czas_przejscia.txt')

# Sporządzenie histogramu
hist, bins = np.histogram(czas_przejscia, bins=50, density=True)

# Zakres wartości dla funkcji gęstości prawdopodobieństwa rozkładu normalnego
x = np.linspace(min(czas_przejscia), max(czas_przejscia), 100)

# Definicja funkcji dla rozkładu normalnego
def normal_distribution(x, loc, scale):
    return norm.pdf(x, loc, scale)

# Dopasowanie funkcji do danych
try:
    mean, std_dev = norm.fit(czas_przejscia)
    print("Parametry dopasowania (mean, std_dev):", mean, std_dev)
except Exception as e:
    print("Błąd podczas dopasowywania funkcji:", e)

# Wykres dopasowanego rozkładu Gaussa
plt.figure(figsize=(10, 6))
plt.hist(czas_przejscia, bins=50, density=True, alpha=0.6, color='b', label='Histogram danych')
plt.plot(x, norm.pdf(x, mean, std_dev), 'r-', linewidth=2, label='Dopasowany rozkład Gaussa')
plt.xlabel('Czas zespołowy (minuty)')
plt.ylabel('Gęstość prawdopodobieństwa')
plt.title('Czas przejścia najazdu w Destiny 2')
plt.legend()
plt.grid(True)
plt.tight_layout()

# Zapisz histogram jako plik PNG
plt.savefig('histogram.png')

# Wyświetl histogram
plt.show()